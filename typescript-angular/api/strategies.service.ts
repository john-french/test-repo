/**
 * Best Next Action API
 * APIs for Best Next Action capabilities.   Note that the error specification used by this API is based  on the IETF draft: https://tools.ietf.org/html/rfc7807 
 *
 * OpenAPI spec version: v1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams }               from '@angular/common/http';

import { Observable }                                        from 'rxjs/Observable';
import '../rxjs-operators';

import { ErrorResponse } from '../model/errorResponse';
import { NewEntityResponse } from '../model/newEntityResponse';
import { StrategiesResponse } from '../model/strategiesResponse';
import { Strategy } from '../model/strategy';
import { StrategyBase } from '../model/strategyBase';
import { StrategyUpdate } from '../model/strategyUpdate';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';


@Injectable()
export class StrategiesService {

    protected basePath = 'https://virtserver.swaggerhub.com/PitneyBowes-CES/Best_Next_Actions/v1';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (let consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Retrieve Strategies
     * Returns all Strategies. Can be filtered by domainId or whether the strategy is active. Use the offset and limit parameters to retrieve subsets of the available Strategies. 
     * @param tenantId Id of the tenant being accessed
     * @param domainId ID of the Domain whose Strategies should be retrieved.
     * @param isActive Return only those strategies that are active or inactive (isActive&#x3D;true or isActive&#x3D;false).
     * @param query Return only those items whose name, description or tags (if available) contain the search string.
     * @param offset Number of items to skip before returning results. Default is 0.
     * @param limit Maximum number of items to return. 0 means return all items. Default is 20.
     * @param sort How to sort returned collection. Comma-separated list of property names, optionally pre-fixed with sort order of &#39;+&#39; for ascending, or &#39;-&#39; for descending. Default sort order is ascending. Default sort field is name. Field names supplied must match a property (of simple data type at the root) of the returned collection, otherwise no sorting is applied.&lt;p&gt;For example, &#39;sort&#x3D;name,-createdWhen&#39; means sort by name (ascending), then by createdWhen (descending).
     */
    public strategiesGet(tenantId: string, domainId?: string, isActive?: boolean, query?: string, offset?: number, limit?: number, sort?: string): Observable<StrategiesResponse> {
        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling strategiesGet.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (domainId !== undefined) {
            queryParameters = queryParameters.set('domainId', <any>domainId);
        }
        if (isActive !== undefined) {
            queryParameters = queryParameters.set('isActive', <any>isActive);
        }
        if (query !== undefined) {
            queryParameters = queryParameters.set('query', <any>query);
        }
        if (offset !== undefined) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (sort !== undefined) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }

        let headers = this.defaultHeaders;
        if (tenantId !== undefined && tenantId !== null) {
            headers = headers.set('TenantId', String(tenantId));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/strategies`,
            {
                params: queryParameters,
                headers: headers,
                withCredentials: this.configuration.withCredentials,
            }
        );
    }

    /**
     * Delete strategy
     * Deletes the specified strategy.
     * @param id ID of the strategy to delete.
     * @param tenantId Id of the tenant being accessed
     */
    public strategiesIdDelete(id: string, tenantId: string): Observable<{}> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling strategiesIdDelete.');
        }
        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling strategiesIdDelete.');
        }

        let headers = this.defaultHeaders;
        if (tenantId !== undefined && tenantId !== null) {
            headers = headers.set('TenantId', String(tenantId));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/strategies/${encodeURIComponent(String(id))}`,
            {
                headers: headers,
                withCredentials: this.configuration.withCredentials,
            }
        );
    }

    /**
     * Retrieve strategy
     * Returns the full details of a strategy.
     * @param id ID of the strategy to return.
     * @param tenantId Id of the tenant being accessed
     */
    public strategiesIdGet(id: string, tenantId: string): Observable<Strategy> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling strategiesIdGet.');
        }
        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling strategiesIdGet.');
        }

        let headers = this.defaultHeaders;
        if (tenantId !== undefined && tenantId !== null) {
            headers = headers.set('TenantId', String(tenantId));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/strategies/${encodeURIComponent(String(id))}`,
            {
                headers: headers,
                withCredentials: this.configuration.withCredentials,
            }
        );
    }

    /**
     * Update strategy
     * Updates a strategy definition.
     * @param id ID of the strategy to update.
     * @param tenantId Id of the tenant being accessed
     * @param forceActive When making a strategy active, if this parameter is false the request is rejected. If this parameter is true the service will make the existing active strategy inactive and make the strategy being updated active. This parameter is ignored if isActive&#x3D;false.
     * @param strategy Updated strategy definition. 
     */
    public strategiesIdPut(id: string, tenantId: string, forceActive?: boolean, strategy?: StrategyUpdate): Observable<{}> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling strategiesIdPut.');
        }
        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling strategiesIdPut.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (forceActive !== undefined) {
            queryParameters = queryParameters.set('forceActive', <any>forceActive);
        }

        let headers = this.defaultHeaders;
        if (tenantId !== undefined && tenantId !== null) {
            headers = headers.set('TenantId', String(tenantId));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.put<any>(`${this.basePath}/strategies/${encodeURIComponent(String(id))}`,
            strategy,
            {
                params: queryParameters,
                headers: headers,
                withCredentials: this.configuration.withCredentials,
            }
        );
    }

    /**
     * Add Strategy
     * Adds a new strategy and returns its unique identifier.
     * @param tenantId Id of the tenant being accessed
     * @param forceActive When creating an active strategy, if this parameter is false the request is rejected. If this parameter is true the service will make the existing active strategy inactive and make the strategy being created active. This parameter is ignored if isActive&#x3D;false.
     * @param strategy Strategy to add.  Note that the strategy must specify a DomainId so that it can be associated with the appropriate Domain. 
     */
    public strategiesPost(tenantId: string, forceActive?: boolean, strategy?: StrategyBase): Observable<NewEntityResponse> {
        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling strategiesPost.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (forceActive !== undefined) {
            queryParameters = queryParameters.set('forceActive', <any>forceActive);
        }

        let headers = this.defaultHeaders;
        if (tenantId !== undefined && tenantId !== null) {
            headers = headers.set('TenantId', String(tenantId));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/strategies`,
            strategy,
            {
                params: queryParameters,
                headers: headers,
                withCredentials: this.configuration.withCredentials,
            }
        );
    }

}
