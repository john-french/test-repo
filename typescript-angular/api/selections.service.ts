/**
 * Best Next Action API
 * APIs for Best Next Action capabilities.   Note that the error specification used by this API is based  on the IETF draft: https://tools.ietf.org/html/rfc7807 
 *
 * OpenAPI spec version: v1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams }               from '@angular/common/http';

import { Observable }                                        from 'rxjs/Observable';
import '../rxjs-operators';

import { ErrorResponse } from '../model/errorResponse';
import { FieldsResult } from '../model/fieldsResult';
import { FieldsSearchResult } from '../model/fieldsSearchResult';
import { NewEntityResponse } from '../model/newEntityResponse';
import { Operators } from '../model/operators';
import { Selection } from '../model/selection';
import { SelectionBase } from '../model/selectionBase';
import { SelectionUpdate } from '../model/selectionUpdate';
import { SelectionUsage } from '../model/selectionUsage';
import { SelectionUsageBase } from '../model/selectionUsageBase';
import { SelectionUsagesResponse } from '../model/selectionUsagesResponse';
import { SelectionsResponse } from '../model/selectionsResponse';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';


@Injectable()
export class SelectionsService {

    protected basePath = 'https://virtserver.swaggerhub.com/PitneyBowes-CES/Best_Next_Actions/v1';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (let consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Return Selection Fields hierarchy
     * Returns Selection Fields for a given path. If the path is empty it is taken to be the root of the Fields tree. If the path is not empty then the Fields below that point in the tree are returned.  By default all Fields below the specified path are returned. The depth parameter can be used to restrict the depth of the returned data. For example if depth&#x3D;1 is specified then only the immdiate child Fields of the specified path are returned. 
     * @param domainId Id of the Domain whose Selection Fields should be returned
     * @param tenantId Id of the tenant being accessed
     * @param path Path of a metadata tree node whose child nodes should be returned
     * @param depth Number of levels of child nodes to return. If this is set to zero or not supplied then the whole tree below the specified path is returned. 
     */
    public selectionFieldsGet(domainId: string, tenantId: string, path?: string, depth?: number): Observable<FieldsResult> {
        if (domainId === null || domainId === undefined) {
            throw new Error('Required parameter domainId was null or undefined when calling selectionFieldsGet.');
        }
        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling selectionFieldsGet.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (domainId !== undefined) {
            queryParameters = queryParameters.set('domainId', <any>domainId);
        }
        if (path !== undefined) {
            queryParameters = queryParameters.set('path', <any>path);
        }
        if (depth !== undefined) {
            queryParameters = queryParameters.set('depth', <any>depth);
        }

        let headers = this.defaultHeaders;
        if (tenantId !== undefined && tenantId !== null) {
            headers = headers.set('TenantId', String(tenantId));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/selectionFields`,
            {
                params: queryParameters,
                headers: headers,
                withCredentials: this.configuration.withCredentials,
            }
        );
    }

    /**
     * Search Selection Fields
     * Returns a flat list of Selection fields where the field&#39;s name contains the search string.       
     * @param domainId Id of the Domain whose Selection Fields should be searched
     * @param query Return only those items whose name contains the search string.
     * @param tenantId Id of the tenant being accessed
     * @param offset Number of items to skip before returning results. Default is 0.
     * @param limit Maximum number of items to return. 0 means return all items. Default is 20.
     */
    public selectionFieldsSearchGet(domainId: string, query: string, tenantId: string, offset?: number, limit?: number): Observable<FieldsSearchResult> {
        if (domainId === null || domainId === undefined) {
            throw new Error('Required parameter domainId was null or undefined when calling selectionFieldsSearchGet.');
        }
        if (query === null || query === undefined) {
            throw new Error('Required parameter query was null or undefined when calling selectionFieldsSearchGet.');
        }
        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling selectionFieldsSearchGet.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (domainId !== undefined) {
            queryParameters = queryParameters.set('domainId', <any>domainId);
        }
        if (query !== undefined) {
            queryParameters = queryParameters.set('query', <any>query);
        }
        if (offset !== undefined) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }

        let headers = this.defaultHeaders;
        if (tenantId !== undefined && tenantId !== null) {
            headers = headers.set('TenantId', String(tenantId));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/selectionFieldsSearch`,
            {
                params: queryParameters,
                headers: headers,
                withCredentials: this.configuration.withCredentials,
            }
        );
    }

    /**
     * Return Selection Operators
     * Returns Selection Operators. If a datatype is specified, only the operators for that datatype are returned. If no datatype is specified, operators for all datatypes are returned. 
     * @param tenantId Id of the tenant being accessed
     * @param datatype Optional - Name of a datatype whose operators are to be returned
     */
    public selectionOperatorsGet(tenantId: string, datatype?: string): Observable<Operators> {
        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling selectionOperatorsGet.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datatype !== undefined) {
            queryParameters = queryParameters.set('datatype', <any>datatype);
        }

        let headers = this.defaultHeaders;
        if (tenantId !== undefined && tenantId !== null) {
            headers = headers.set('TenantId', String(tenantId));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/selectionOperators`,
            {
                params: queryParameters,
                headers: headers,
                withCredentials: this.configuration.withCredentials,
            }
        );
    }

    /**
     * Retrieve Selection Usages
     * Returns a collection of Selection Usages, optionally filtered by a specific Action or Selection. Either a selectionId or an actionId can be supplied. An error occurs if both IDs are supplied .  There are two types of Selection Usage - Direct and Indirect.  An indirect usage associates a Selection with an Action Tag and hence indirectly with any Action that uses that Tag.  The Selection Usage objects returned have various properties that are either empty or populated depending on whether it is a direct or indirect Usage. 
     * @param tenantId Id of the tenant being accessed
     * @param actionId ID of the Action instance whose Selection Usages are to be returned.
     * @param selectionId ID of the Selection whose Selection Usages are to be returned.
     * @param offset Number of items to skip before returning results. Default is 0.
     * @param limit Maximum number of items to return. 0 means return all items. Default is 20.
     */
    public selectionUsagesGet(tenantId: string, actionId?: string, selectionId?: string, offset?: number, limit?: number): Observable<SelectionUsagesResponse> {
        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling selectionUsagesGet.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (actionId !== undefined) {
            queryParameters = queryParameters.set('actionId', <any>actionId);
        }
        if (selectionId !== undefined) {
            queryParameters = queryParameters.set('selectionId', <any>selectionId);
        }
        if (offset !== undefined) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }

        let headers = this.defaultHeaders;
        if (tenantId !== undefined && tenantId !== null) {
            headers = headers.set('TenantId', String(tenantId));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/selectionUsages`,
            {
                params: queryParameters,
                headers: headers,
                withCredentials: this.configuration.withCredentials,
            }
        );
    }

    /**
     * Associate a Selection with an Action or Action Tag.
     * Associate an existing Selection with an Action or an Action Tag. Within the supplied object, the Selection ID must be supplied plus either an Action ID or an Action Tag ID. An error occurs if both actionId and an tagId are supplied. 
     * @param selectionUsage New selection Usage
     * @param tenantId Id of the tenant being accessed
     */
    public selectionUsagesPost(selectionUsage: SelectionUsageBase, tenantId: string): Observable<NewEntityResponse> {
        if (selectionUsage === null || selectionUsage === undefined) {
            throw new Error('Required parameter selectionUsage was null or undefined when calling selectionUsagesPost.');
        }
        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling selectionUsagesPost.');
        }

        let headers = this.defaultHeaders;
        if (tenantId !== undefined && tenantId !== null) {
            headers = headers.set('TenantId', String(tenantId));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];
        let httpContentTypeSelected:string = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/selectionUsages`,
            selectionUsage,
            {
                headers: headers,
                withCredentials: this.configuration.withCredentials,
            }
        );
    }

    /**
     * Remove a Selection Usage
     * Remove the association between a Selection and an Action or Action Tag.
     * @param selectionUsageId ID of the Selection Usage to remove
     * @param tenantId Id of the tenant being accessed
     */
    public selectionUsagesSelectionUsageIdDelete(selectionUsageId: string, tenantId: string): Observable<{}> {
        if (selectionUsageId === null || selectionUsageId === undefined) {
            throw new Error('Required parameter selectionUsageId was null or undefined when calling selectionUsagesSelectionUsageIdDelete.');
        }
        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling selectionUsagesSelectionUsageIdDelete.');
        }

        let headers = this.defaultHeaders;
        if (tenantId !== undefined && tenantId !== null) {
            headers = headers.set('TenantId', String(tenantId));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/selectionUsages/${encodeURIComponent(String(selectionUsageId))}`,
            {
                headers: headers,
                withCredentials: this.configuration.withCredentials,
            }
        );
    }

    /**
     * Return a Selection Usage
     * Returns the details of the association between a Selection and an Action or Action Tag. Note that certain properties in the response object will be empty or populated depending on the type of Usage (direct or indirect Usage). 
     * @param selectionUsageId ID of the Selection Usage to return
     * @param tenantId Id of the tenant being accessed
     */
    public selectionUsagesSelectionUsageIdGet(selectionUsageId: string, tenantId: string): Observable<SelectionUsage> {
        if (selectionUsageId === null || selectionUsageId === undefined) {
            throw new Error('Required parameter selectionUsageId was null or undefined when calling selectionUsagesSelectionUsageIdGet.');
        }
        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling selectionUsagesSelectionUsageIdGet.');
        }

        let headers = this.defaultHeaders;
        if (tenantId !== undefined && tenantId !== null) {
            headers = headers.set('TenantId', String(tenantId));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/selectionUsages/${encodeURIComponent(String(selectionUsageId))}`,
            {
                headers: headers,
                withCredentials: this.configuration.withCredentials,
            }
        );
    }

    /**
     * Retrieve Selections
     * Returns all Selections. Can be filtered by domainId, actionMetadataId or subjectMetadataId. If more than one of these IDs is supplied an error is returned. Use the offset and limit parameters to retrieve subsets of the available Selections. 
     * @param tenantId Id of the tenant being accessed
     * @param domainId ID of the Domain whose Selections should be retrieved.
     * @param actionMetadataId Return only those selections that refer to this action metadata.
     * @param subjectMetadataId Return only those selections that refer to this subject metadata.
     * @param scope Return only those selections that have this scope (Action or DomainWide).
     * @param detail Specifies the level of detail to be returned. Options are Summary and Full. Default is Summary. 
     * @param query Return only those items whose name, description or tags (if available) contain the search string.
     * @param offset Number of items to skip before returning results. Default is 0.
     * @param limit Maximum number of items to return. 0 means return all items. Default is 20.
     * @param sort How to sort returned collection. Comma-separated list of property names, optionally pre-fixed with sort order of &#39;+&#39; for ascending, or &#39;-&#39; for descending. Default sort order is ascending. Default sort field is name. Field names supplied must match a property (of simple data type at the root) of the returned collection, otherwise no sorting is applied.&lt;p&gt;For example, &#39;sort&#x3D;name,-createdWhen&#39; means sort by name (ascending), then by createdWhen (descending).
     */
    public selectionsGet(tenantId: string, domainId?: string, actionMetadataId?: string, subjectMetadataId?: string, scope?: string, detail?: string, query?: string, offset?: number, limit?: number, sort?: string): Observable<SelectionsResponse> {
        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling selectionsGet.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (domainId !== undefined) {
            queryParameters = queryParameters.set('domainId', <any>domainId);
        }
        if (actionMetadataId !== undefined) {
            queryParameters = queryParameters.set('actionMetadataId', <any>actionMetadataId);
        }
        if (subjectMetadataId !== undefined) {
            queryParameters = queryParameters.set('subjectMetadataId', <any>subjectMetadataId);
        }
        if (scope !== undefined) {
            queryParameters = queryParameters.set('scope', <any>scope);
        }
        if (detail !== undefined) {
            queryParameters = queryParameters.set('detail', <any>detail);
        }
        if (query !== undefined) {
            queryParameters = queryParameters.set('query', <any>query);
        }
        if (offset !== undefined) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (sort !== undefined) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }

        let headers = this.defaultHeaders;
        if (tenantId !== undefined && tenantId !== null) {
            headers = headers.set('TenantId', String(tenantId));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/selections`,
            {
                params: queryParameters,
                headers: headers,
                withCredentials: this.configuration.withCredentials,
            }
        );
    }

    /**
     * Delete Selection
     * Deletes the specified Selection.
     * @param id ID of the Selection to delete.
     * @param tenantId Id of the tenant being accessed
     */
    public selectionsIdDelete(id: string, tenantId: string): Observable<{}> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling selectionsIdDelete.');
        }
        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling selectionsIdDelete.');
        }

        let headers = this.defaultHeaders;
        if (tenantId !== undefined && tenantId !== null) {
            headers = headers.set('TenantId', String(tenantId));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/selections/${encodeURIComponent(String(id))}`,
            {
                headers: headers,
                withCredentials: this.configuration.withCredentials,
            }
        );
    }

    /**
     * Retrieve Selection
     * Returns the full details of a selection.
     * @param id ID of the Selection to return.
     * @param tenantId Id of the tenant being accessed
     */
    public selectionsIdGet(id: string, tenantId: string): Observable<Selection> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling selectionsIdGet.');
        }
        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling selectionsIdGet.');
        }

        let headers = this.defaultHeaders;
        if (tenantId !== undefined && tenantId !== null) {
            headers = headers.set('TenantId', String(tenantId));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/selections/${encodeURIComponent(String(id))}`,
            {
                headers: headers,
                withCredentials: this.configuration.withCredentials,
            }
        );
    }

    /**
     * Update Selection
     * Updates a Selection definition.
     * @param id ID of the Selection to update.
     * @param tenantId Id of the tenant being accessed
     * @param forceScopeChange If the scope of the Selection has changed the service will normally reject the request if there is an existing usage in the current scope. When this flag is set to true the service will remove any existing usages (Action, Tag or DomainWide) and then change the scope. Use with caution.
     * @param selection Updated Selection definition. If the DomainId in the updated Selection is different to the existing DomainId for this Selection the Selection will be moved into the specified Domain unless it is in use in the existing Domain, in which case a conflict error occurs.  
     */
    public selectionsIdPut(id: string, tenantId: string, forceScopeChange?: boolean, selection?: SelectionUpdate): Observable<{}> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling selectionsIdPut.');
        }
        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling selectionsIdPut.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (forceScopeChange !== undefined) {
            queryParameters = queryParameters.set('forceScopeChange', <any>forceScopeChange);
        }

        let headers = this.defaultHeaders;
        if (tenantId !== undefined && tenantId !== null) {
            headers = headers.set('TenantId', String(tenantId));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.put<any>(`${this.basePath}/selections/${encodeURIComponent(String(id))}`,
            selection,
            {
                params: queryParameters,
                headers: headers,
                withCredentials: this.configuration.withCredentials,
            }
        );
    }

    /**
     * Add Selection
     * Adds a new Selection and returns its unique identifier.
     * @param tenantId Id of the tenant being accessed
     * @param selection Selection to add.  Note that the Selection must specify a DomainId so that it can be associated with the appropriate Domain. 
     */
    public selectionsPost(tenantId: string, selection?: SelectionBase): Observable<NewEntityResponse> {
        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling selectionsPost.');
        }

        let headers = this.defaultHeaders;
        if (tenantId !== undefined && tenantId !== null) {
            headers = headers.set('TenantId', String(tenantId));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/selections`,
            selection,
            {
                headers: headers,
                withCredentials: this.configuration.withCredentials,
            }
        );
    }

}
