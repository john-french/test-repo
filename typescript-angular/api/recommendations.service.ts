/**
 * Best Next Action API
 * APIs for Best Next Action capabilities.   Note that the error specification used by this API is based  on the IETF draft: https://tools.ietf.org/html/rfc7807 
 *
 * OpenAPI spec version: v1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams }               from '@angular/common/http';

import { Observable }                                        from 'rxjs/Observable';
import '../rxjs-operators';

import { RecommendationRequest } from '../model/recommendationRequest';
import { RecommendationsResponse } from '../model/recommendationsResponse';
import { RequestHistoryResult } from '../model/requestHistoryResult';
import { ResponseToRecommendation } from '../model/responseToRecommendation';
import { TreatmentHistoryResult } from '../model/treatmentHistoryResult';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';


@Injectable()
export class RecommendationsService {

    protected basePath = 'https://virtserver.swaggerhub.com/PitneyBowes-CES/Best_Next_Actions/v1';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (let consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Get request history
     * Retrieves Request History for a subject.  Unlike /history/treatments, this operation returns detailed information about the request, such as the Agent, Application, Location, etc.  Each Request History item contains a collection of Treatment HIstory items.  Results are ordered by descending requestTimestamp - i.e. most recent first. 
     * @param subjectIdentifier External identifier for the subject
     * @param tenantId Id of the tenant being accessed
     * @param system Name of the external system for which the subject identifier is valid. If not supplied, the default system is assumed. 
     * @param requestId ID of an individual request to retrieve. If a requestId is specified the channel and conversation are ignored. 
     * @param channel Optional name of the channel. If provided, only Requests on the specified channel are returned. 
     * @param conversation Optional ID of the conversation.  If provided, only Requests within the specified conversation are returned. 
     * @param offset Number of items to skip before returning results. Default is 0.
     * @param limit Maximum number of items to return. 0 means return all items. Default is 20.
     */
    public historyRequestsGet(subjectIdentifier: string, tenantId: string, system?: string, requestId?: number, channel?: string, conversation?: string, offset?: number, limit?: number): Observable<RequestHistoryResult> {
        if (subjectIdentifier === null || subjectIdentifier === undefined) {
            throw new Error('Required parameter subjectIdentifier was null or undefined when calling historyRequestsGet.');
        }
        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling historyRequestsGet.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (subjectIdentifier !== undefined) {
            queryParameters = queryParameters.set('subjectIdentifier', <any>subjectIdentifier);
        }
        if (system !== undefined) {
            queryParameters = queryParameters.set('system', <any>system);
        }
        if (requestId !== undefined) {
            queryParameters = queryParameters.set('requestId', <any>requestId);
        }
        if (channel !== undefined) {
            queryParameters = queryParameters.set('channel', <any>channel);
        }
        if (conversation !== undefined) {
            queryParameters = queryParameters.set('conversation', <any>conversation);
        }
        if (offset !== undefined) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }

        let headers = this.defaultHeaders;
        if (tenantId !== undefined && tenantId !== null) {
            headers = headers.set('TenantId', String(tenantId));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<any>(`${this.basePath}/history/requests`,
            {
                params: queryParameters,
                headers: headers,
                withCredentials: this.configuration.withCredentials,
            }
        );
    }

    /**
     * Get treatment history
     * Retrieves Treatment History for a subject.  Results are ordered by descending treatmentTimestamp - i.e. most recent first. 
     * @param subjectIdentifier External identifier for the subject
     * @param tenantId Id of the tenant being accessed
     * @param system Name of the external system for which the subject identifier is valid. If not supplied, the default system is assumed. 
     * @param channel Optional name of the channel. If provided, only Treatments on the specified channel are returned. 
     * @param conversation Optional ID of the conversation.  If provided, only Treatments within the specified conversation are returned. 
     * @param consolidate If true (default), when more than one Treatment exists for the same Action,  only the most recent treatment for that action is returned.  If one or more Treatment has a Response associated with it, the  most recent Treatment with a Response is returned (for each Action).  For any Treatment with multiple Responses, consolidate&#x3D;true means that only the most recent Response for the Treatment will be returned.  When this flag is set to false, all Treatments are returned. It is possible for many Treatments to be returned for each Action and for each Treatment to contain many Responses. 
     * @param minResponses Treatments will only be returned if they have at least this many Responses. The default is zero, whcih means that all Treatments are returned, even if they do not have a response. 
     * @param offset Number of items to skip before returning results. Default is 0.
     * @param limit Maximum number of items to return. 0 means return all items. Default is 20.
     */
    public historyTreatmentsGet(subjectIdentifier: string, tenantId: string, system?: string, channel?: string, conversation?: string, consolidate?: boolean, minResponses?: number, offset?: number, limit?: number): Observable<TreatmentHistoryResult> {
        if (subjectIdentifier === null || subjectIdentifier === undefined) {
            throw new Error('Required parameter subjectIdentifier was null or undefined when calling historyTreatmentsGet.');
        }
        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling historyTreatmentsGet.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (subjectIdentifier !== undefined) {
            queryParameters = queryParameters.set('subjectIdentifier', <any>subjectIdentifier);
        }
        if (system !== undefined) {
            queryParameters = queryParameters.set('system', <any>system);
        }
        if (channel !== undefined) {
            queryParameters = queryParameters.set('channel', <any>channel);
        }
        if (conversation !== undefined) {
            queryParameters = queryParameters.set('conversation', <any>conversation);
        }
        if (consolidate !== undefined) {
            queryParameters = queryParameters.set('consolidate', <any>consolidate);
        }
        if (minResponses !== undefined) {
            queryParameters = queryParameters.set('minResponses', <any>minResponses);
        }
        if (offset !== undefined) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }

        let headers = this.defaultHeaders;
        if (tenantId !== undefined && tenantId !== null) {
            headers = headers.set('TenantId', String(tenantId));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<any>(`${this.basePath}/history/treatments`,
            {
                params: queryParameters,
                headers: headers,
                withCredentials: this.configuration.withCredentials,
            }
        );
    }

    /**
     * Get Recommendations for a Subject
     * Retrieves a list of prioritised Recommendations based on a supplied Subject. A subjectIdentifier must be provided.  If a subject entity is supplied it must conform to the SubjectMetadata defined for the Domain.  The context parameter must be supplied and it must contain at least a domainName. 
     * @param recommendationRequest Object containing the subjectIdentifier and/or object plus a recommendationContext. 
     * @param tenantId Id of the tenant being accessed
     */
    public recommendationsPost(recommendationRequest: RecommendationRequest, tenantId: string): Observable<RecommendationsResponse> {
        if (recommendationRequest === null || recommendationRequest === undefined) {
            throw new Error('Required parameter recommendationRequest was null or undefined when calling recommendationsPost.');
        }
        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling recommendationsPost.');
        }

        let headers = this.defaultHeaders;
        if (tenantId !== undefined && tenantId !== null) {
            headers = headers.set('TenantId', String(tenantId));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/recommendations`,
            recommendationRequest,
            {
                headers: headers,
                withCredentials: this.configuration.withCredentials,
            }
        );
    }

    /**
     * Record a response
     * Records a response to a recommendation previously provided for a subject. 
     * @param response Object containing the recommendationId, responseType and optionally a conversationId. 
     * @param tenantId Id of the tenant being accessed
     */
    public responsesPost(response: ResponseToRecommendation, tenantId: string): Observable<{}> {
        if (response === null || response === undefined) {
            throw new Error('Required parameter response was null or undefined when calling responsesPost.');
        }
        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling responsesPost.');
        }

        let headers = this.defaultHeaders;
        if (tenantId !== undefined && tenantId !== null) {
            headers = headers.set('TenantId', String(tenantId));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/responses`,
            response,
            {
                headers: headers,
                withCredentials: this.configuration.withCredentials,
            }
        );
    }

}
